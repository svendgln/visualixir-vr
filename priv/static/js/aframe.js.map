{"version":3,"sources":["aframe/aframeApp.js","aframe/components/clicktest.js","aframe/components/customcontrols.js","aframe/components/debug.js","aframe/components/enterleave.js","aframe/components/menu.js","aframe/components/menubutton.js","aframe/test.js","aframe/user_socket.js","node_modules/phoenix_html/priv/static/phoenix_html.js","node_modules/phoenix/priv/static/phoenix.cjs.js"],"names":["console","log","window","socket","components","forEach","c","require","AFRAME","registerComponent","init","el","addEventListener","evt","setAttribute","getAttribute","schema","cameraRig","type","camera","speed","controllerLeft","controllerRight","self","timer","quat","THREE","Quaternion","vecZ","Vector3","vecX","axis","detail","tick","time","timeDelta","pos","data","object3D","position","copy","quaternion","applyQuaternion","axisX","axisZ","normalize","multiplyScalar","add","set","x","getComponent","y","z","rot","rotation","line","document","querySelectorAll","vecz","vecx","l","setFromQuaternion","querySelector","entity","newParent","cloneNode","appendChild","parentNode","removeChild","Test","container","channel","updateNodes","msg","update","nodes","join","receive","on","t","color","text","id","material","r","g","b","highlightColor","Color","offsetHSL","colorHex","getHexString","highlightHex","DATA","renderData","d3","select","selectAll","enter","append","attr","d","i","test","linksOLD","source","target","links","addNode","unshift","sim","alpha","restart","addLink","link","index","push","force","forceSimulation","forceManyBody","strength","forceCenter","forceLink","distance","forceX","forceY","velocityDecay","alphaDecay","ticked","setTimeout","Socket","params","token","userToken","connect"],"mappings":"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AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../priv/static/js/aframe.js","sourcesContent":["console.log(\"loading aframe app\");\r\n\r\n// const fs = require('fs');\r\n\r\n// function loadComponents() {\r\n//     const path = './components';\r\n//     let files = fs.readdirSync(path).filter(file => file.endsWith('.js'));\r\n//     console.log(files)\r\n// }\r\n\r\n//import \"phoenix_html\";\r\nimport socket from \"./user_socket.js\";\r\nwindow.socket = socket;\r\n//window.socket.channel(\"nodes\", {}).join().receive(\"ok\", () => console.log('FRFRFRF'));\r\n// temp fix\r\nconst components = ['clicktest.js', 'customcontrols.js', 'debug.js', 'enterleave.js', 'menubutton.js', 'menu.js']\r\ncomponents.forEach(c => require(`./components/${c}`))\r\n\r\nimport './test.js';\r\n","\r\nAFRAME.registerComponent('clicktest', {\r\n    init: function () {\r\n        console.log('CLICK INIT');\r\n        var el = this.el;\r\n        el.addEventListener('click', evt => {\r\n            console.log(el);\r\n            console.log('trigger pressed');\r\n            el.setAttribute('visible', !el.getAttribute('visible'));\r\n        });\r\n    }\r\n})","AFRAME.registerComponent('custom-controls', {\r\n    schema: {\r\n        cameraRig: { type: 'selector', default: '#cameraRig' },\r\n        camera: { type: 'selector', default: '#camera' },\r\n        speed: { type: 'number', default: 0.1 },\r\n        controllerLeft: { 'type': 'selector', default: '#controllerLeft' },\r\n        controllerRight: { 'type': 'selector', default: '#controllerRight' }\r\n    },\r\n\r\n    init: function () {\r\n        console.log('custom controls loaded');\r\n        const el = this.el; //probs not needed\r\n        const self = this;\r\n        this.timer = 0;\r\n        this.quat = new THREE.Quaternion();\r\n        this.vecZ = new THREE.Vector3(0, 0, -1); //forward direction of camera -z\r\n        this.vecX = new THREE.Vector3(1, 0, 0); // x axis for sideways movement\r\n        this.axis = [0, 0]; //controller trackpad x,z axis\r\n\r\n\r\n        // controller events\r\n        // trigger\r\n        controllerLeft.addEventListener('triggerdown', evt => {\r\n            console.log('LEFT TRIGGER');\r\n            \r\n        });\r\n        controllerRight.addEventListener('triggerdown', evt => {\r\n            console.log('RIGHT TRIGGER');\r\n        });\r\n\r\n        // grip button\r\n        controllerLeft.addEventListener('gripdown', evt => {\r\n            console.log('LEFT GRIP');\r\n        });\r\n\r\n        controllerRight.addEventListener('gripdown', evt => {\r\n            console.log('RIGHT GRIP');\r\n        });\r\n\r\n        // menu button\r\n        controllerLeft.addEventListener('menudown', evt => {\r\n            console.log('LEFT MENU');\r\n        });\r\n\r\n        controllerRight.addEventListener('menudown', evt => {\r\n            console.log('RIGHT MENU');\r\n            //call this.somefunction toggle menu idk\r\n        });\r\n\r\n        // trackpad\r\n        controllerLeft.addEventListener('axismove', evt => {\r\n            //position on trackpad, x,z values [-1,1]\r\n            const axis = evt.detail.axis;\r\n            this.axis = axis;\r\n        });\r\n\r\n        //right trackpad: use click and axis location to create arrow key functionality?.. for.. something..\r\n    },\r\n\r\n    tick: function (time, timeDelta) {\r\n        const vecX = this.vecX;\r\n        const vecZ = this.vecZ;\r\n\r\n        const pos = this.data.cameraRig.object3D.position;\r\n        //camera rotation quaternion\r\n        this.quat.copy(this.data.camera.object3D.quaternion);\r\n        //apply to direction vectors\r\n        vecZ.applyQuaternion(this.quat);\r\n        vecX.applyQuaternion(this.quat);\r\n\r\n        // scale vecs with speed scalar, add to position..\r\n        const axis = this.axis;\r\n        const axisX = axis[0] * this.data.speed;\r\n        const axisZ = axis[1] * this.data.speed;\r\n        // length 1\r\n        vecZ.normalize();\r\n        vecX.normalize();\r\n        // closer to edge of trackpad = faster\r\n        vecZ.multiplyScalar(axisZ);\r\n        vecX.multiplyScalar(axisX);\r\n\r\n        pos.add(vecZ);\r\n        // add x component of vecX to position: only vecZ changes height\r\n        this.data.cameraRig.object3D.position.set(pos.x + vecX.getComponent(0), pos.y, pos.z);\r\n        // reset NEEDED?\r\n        this.vecZ.set(0, 0, -1);\r\n        this.vecX.set(1, 0, 0);\r\n    }\r\n});","\r\nAFRAME.registerComponent('testing', {\r\n    schema: {\r\n        cameraRig: { type: 'selector', default: '#cameraRig' },\r\n        camera: { type: 'selector', default: '#camera' }\r\n    },\r\n    init: function () {\r\n        console.log('testing component loaded');\r\n        this.timer = 0;\r\n    },\r\n    tick: function (time, timeDelta) {\r\n        this.timer += timeDelta\r\n        if (this.timer > 1000) {\r\n            this.timer = 0\r\n            //console.log('log test')\r\n            //TEST\r\n            const rot = this.data.camera.object3D.rotation;\r\n            const quat = this.data.camera.object3D.quaternion;\r\n\r\n            const line = document.querySelectorAll('#LINE');\r\n            var vecz = new THREE.Vector3(0, 0, -1);\r\n            var vecx = new THREE.Vector3(1, 0, 0);\r\n            vecx.applyQuaternion(quat); //cam rotation\r\n            vecz.applyQuaternion(quat);\r\n            line.forEach(l => {\r\n                l.object3D.rotation.setFromQuaternion(quat);\r\n            });\r\n            //var currentPos = this.data.cameraRig.object3D.position;\r\n            //currentPos.add(vecz);\r\n            //console.log(this.data.cameraRig.object3D.position, currentPos);\r\n        }\r\n    }\r\n});","// component needed?\r\nAFRAME.registerComponent('enterleave', {\r\n    init: function () {\r\n        var el = this.el;\r\n        console.log(this.el);\r\n        console.log('enter/leave');\r\n        el.addEventListener('enterleave', function (evt) {\r\n            console.log('(╯°□°）╯︵ ┻━┻')\r\n        })\r\n    }\r\n})","\r\nAFRAME.registerComponent('menu', {\r\n    init: function () {\r\n        console.log('menu init');\r\n\r\n        document.querySelector('a-scene').addEventListener('enter-vr', function () {\r\n            console.log(\"ENTERED VR\");\r\n            // attach menu to controller\r\n\r\n            let entity = document.querySelector('#menu');\r\n            let newParent = document.querySelector('#controllerRight');\r\n            //entity.flushToDOM(); //not needed? dafuq\r\n            let copy = entity.cloneNode(true);\r\n            newParent.appendChild(copy);\r\n            entity.parentNode.removeChild(entity);\r\n            //resize\r\n            copy.setAttribute('scale', '0.5 0.5 0.5');\r\n        });\r\n\r\n\r\n\r\n    }\r\n});\r\n\r\n// AFRAME.registerSystem('menu', {\r\n//     init: function () {\r\n//         console.log('CCCCCCCCCCCCCCCCCC');\r\n//         this.commands = new Map();\r\n//         this.channel = window.socket.channel(\"nodes\", {});\r\n//         this.nodesContainer = document.querySelector('#menu-nodes');\r\n\r\n//         let updateNodes = msg => {\r\n//             this.update(msg.nodes);\r\n//         };\r\n\r\n//         this.channel.join().receive(\"ok\", updateNodes);\r\n//         // update msg callback\r\n//         this.channel.on(\"update\", updateNodes);\r\n//     },\r\n\r\n//     updateNodes: function (nodes) {\r\n//         console.log('yeet');\r\n//     }\r\n// });\r\n\r\nexport default class Test {\r\n    constructor(container) {\r\n        this.container = container;\r\n        this.channel = window.socket.channel(\"nodes\", {});\r\n\r\n        let updateNodes = msg => {\r\n            this.update(msg.nodes);\r\n        };\r\n\r\n        this.channel.join().receive(\"ok\", updateNodes);\r\n        // update msg callback\r\n        this.channel.on(\"update\", updateNodes);\r\n    }\r\n\r\n    update(nodes) {\r\n        console.log('updating nodes: ', nodes);\r\n    }\r\n}\r\n//temp :p\r\nlet t = new Test(\"aa\");\r\n//t.update(\"a\");","console.log('MENU BUTTON LOADED');\r\nAFRAME.registerComponent('menu-button', {\r\n    /**\r\n     * schema: color and text, idk what else\r\n     */\r\n    schema: {\r\n        color: { type: 'color', default: '#FF0000' },\r\n        text: { type: 'string', default: 'button' }\r\n    },\r\n\r\n    init: function () {\r\n        const el = this.el;\r\n        console.log('ID: ', this.id);\r\n        //console.log('test: ', makeButton('#00FF00'));\r\n\r\n        const color = el.components.material.material.color;\r\n        const { r, g, b } = color;\r\n        const highlightColor = new THREE.Color(r, g, b);\r\n        highlightColor.offsetHSL(0.5, 0, 0);\r\n\r\n        const colorHex = `#${color.getHexString()}`;\r\n        const highlightHex = `#${highlightColor.getHexString()}`;\r\n\r\n        console.log(new THREE.Color(1, 0, 0).getHexString())\r\n\r\n        el.setAttribute('animation__mouseenter', \"property: components.material.material.color; type: color; to: \" + highlightHex + \"; startEvents: mouseenter; dur: 50\");\r\n        el.setAttribute('animation__mouseleave', \"property: components.material.material.color; type: color; to: \" + colorHex + \"; startEvents: mouseleave; dur: 50\");\r\n        el.setAttribute('animation__click', \"property: scale; from: 1 1 1; to: 1.1 1.1 1.1; startEvents: click; dur: 200; dir: alternate\");\r\n        el.setAttribute('animation__click2', \"property: scale; from: 1.1 1.1 1.1; to: 1 1 1; startEvents: click; dur: 200; delay: 200\");\r\n\r\n        el.addEventListener('click', evt => {\r\n            console.log(evt);\r\n            // evt.target for clicked el\r\n        });\r\n\r\n        // test\r\n        // let geometry = el.getObject3D('mesh').geometry;\r\n        // console.log('geometry: ', geometry);\r\n\r\n        // let edges = new THREE.EdgesGeometry(geometry);\r\n        // let line = new THEE.lineSegments(edges, new THREE.LineBasicMaterial({\r\n        //     color: 0xffffff\r\n        // }));\r\n\r\n    }\r\n});\r\n\r\n\r\n\r\n\r\n// function makeButton(color) {\r\n//     const colorRegex = /^#([0-9a-f]{3}){1,2}$/i;\r\n//     if (!colorRegex.test(color)) {\r\n//         color = '#FF0000';\r\n//     }\r\n//     let el = document.createElement('a-entity');\r\n\r\n\r\n//     return el;\r\n//     return `\r\n//     <a-entity\r\n//         geometry=\"primitive: cylinder; height: 0.1; radius: 0.15\"\r\n//         material={\\`shader: flat; color: ${color}; transparent: true; opacity: 0.5\\`}\r\n//         rotation=\"90 0 0\"\r\n//         position=\"-0.3 0.3 0\"\r\n//     ></a-entity>\r\n//     `\r\n// }","console.log('test loaded');\r\n\r\nconst DATA = [\r\n    { x: 10, y: 10 },\r\n    { x: 2, y: 2 },\r\n    { x: 4, y: 4 },\r\n    { x: 6, y: 6 },\r\n    { x: 8, y: 8 }\r\n];\r\n\r\ndocument.querySelector('a-scene #d3-container')\r\n    .addEventListener('loaded', console.log('el loaded'))\r\n\r\n// old tests\r\nfunction renderData() {\r\n\r\n    d3.select('a-scene').select('#d3-container').selectAll('a-entity')\r\n        .data(DATA)\r\n        .enter()\r\n        .append('a-entity')\r\n        .attr('geometry', function (d, i) {\r\n            return `primitive: sphere; radius: 1`\r\n        })\r\n        .attr('position', function (d, i) {\r\n            console.log('adding sphere on pos', d.x, d.y);\r\n            return `${d.x} 1 ${d.y}`\r\n        })\r\n        .attr('material', function (d, i) {\r\n            return `shader: standard; color: red`\r\n        });\r\n}\r\n\r\n\r\n// test force simulation:\r\nconst nodes = [{ test: 'lol' }, {}, {}, {}, {}];\r\nconst linksOLD = [\r\n    { source: 0, target: 1 },\r\n    { source: 1, target: 2 },\r\n    { source: 2, target: 3 },\r\n    { source: 3, target: 4 }\r\n];\r\n\r\nconst links = [\r\n    { source: 0, target: 3 },\r\n    { source: 2, target: 4 },\r\n]\r\n\r\n// temp testing function\r\nfunction addNode() {\r\n    nodes.unshift({});\r\n    sim.nodes(nodes);\r\n    sim.alpha(1).restart();\r\n}\r\n\r\nfunction addLink(source, target) {\r\n    if (source && target) {\r\n        let link = {source: source.index, target: target.index}\r\n        links.push(link)\r\n        console.log(links)\r\n        sim.force('link').links(links);\r\n        // no check if exists..\r\n        sim.alpha(1).restart();\r\n   }\r\n}\r\n\r\nconst sim = d3.forceSimulation(nodes)\r\n    .force('charge', d3.forceManyBody().strength(-10)) //default\r\n    .force('center', d3.forceCenter(0, 0))\r\n    .force('link', d3.forceLink().distance(1).links(links))\r\n    .force('x', d3.forceX().strength(0.5))\r\n    .force('y', d3.forceY().strength(0.5))\r\n    .velocityDecay(0.2)\r\n    .alphaDecay(0.02)\r\n    .on('tick', ticked);\r\n\r\n\r\nfunction ticked() {\r\n    const container = d3.select('a-scene').select('#d3-nodes')\r\n        .selectAll('a-entity')\r\n        .data(nodes)\r\n        .join('a-entity')\r\n        .attr('geometry', function (d, i) {\r\n            return `primitive: sphere; radius: 1`\r\n        })\r\n        .attr('position', function (d, i) {\r\n            return `${d.x} 1 ${d.y}`\r\n        })\r\n        .attr('material', function (d, i) {\r\n            return `shader: standard; color: red`\r\n        });\r\n\r\n    let test = d3.select('#d3-links').selectAll('a-entity').data(links, d => `${d.source}-${d.target}`)\r\n        .join('a-entity');\r\n        test.attr('line', function (d, i) {\r\n            let source = nodes[d.source.index];\r\n            let target = nodes[d.target.index];\r\n            //console.log(d);\r\n            return `start: ${source.x} 0 ${source.y}; end: ${target.x} 0 ${target.y}; color: green`\r\n        });\r\n\r\n    // links.enter()\r\n    //     .append('a-entity')\r\n    //     .attr('line', function (d, i) {\r\n    //         let source = nodes[d.source];\r\n    //         let target = nodes[d.target];\r\n    //         return `start: ${source.x} 0 ${source.y}; end: ${target.x} 0 ${target.y}; color: green`\r\n    //     })\r\n}\r\n\r\nfunction test() {\r\n    console.log('adding node..');\r\n    addNode();\r\n    setTimeout(() => console.log('adding link..'), 1000);\r\n    setTimeout(() => addLink(nodes[0], nodes[5]), 1000);\r\n}\r\n//..\r\ndocument.test = test;","// NOTE: The contents of this file will only be executed if\r\n// you uncomment its entry in \"assets/js/app.js\".\r\n\r\n// Bring in Phoenix channels client library:\r\nimport {Socket} from \"phoenix\"\r\n\r\n// And connect to the path in \"lib/visualixir_vr_web/endpoint.ex\". We pass the\r\n// token for authentication. Read below how it should be used.\r\nlet socket = new Socket(\"/socket\", {params: {token: window.userToken}})\r\n\r\n// When you connect, you'll often need to authenticate the client.\r\n// For example, imagine you have an authentication plug, `MyAuth`,\r\n// which authenticates the session and assigns a `:current_user`.\r\n// If the current user exists you can assign the user's token in\r\n// the connection for use in the layout.\r\n//\r\n// In your \"lib/visualixir_vr_web/router.ex\":\r\n//\r\n//     pipeline :browser do\r\n//       ...\r\n//       plug MyAuth\r\n//       plug :put_user_token\r\n//     end\r\n//\r\n//     defp put_user_token(conn, _) do\r\n//       if current_user = conn.assigns[:current_user] do\r\n//         token = Phoenix.Token.sign(conn, \"user socket\", current_user.id)\r\n//         assign(conn, :user_token, token)\r\n//       else\r\n//         conn\r\n//       end\r\n//     end\r\n//\r\n// Now you need to pass this token to JavaScript. You can do so\r\n// inside a script tag in \"lib/visualixir_vr_web/templates/layout/app.html.heex\":\r\n//\r\n//     <script>window.userToken = \"<%= assigns[:user_token] %>\";</script>\r\n//\r\n// You will need to verify the user token in the \"connect/3\" function\r\n// in \"lib/visualixir_vr_web/channels/user_socket.ex\":\r\n//\r\n//     def connect(%{\"token\" => token}, socket, _connect_info) do\r\n//       # max_age: 1209600 is equivalent to two weeks in seconds\r\n//       case Phoenix.Token.verify(socket, \"user socket\", token, max_age: 1_209_600) do\r\n//         {:ok, user_id} ->\r\n//           {:ok, assign(socket, :user, user_id)}\r\n//\r\n//         {:error, reason} ->\r\n//           :error\r\n//       end\r\n//     end\r\n//\r\n// Finally, connect to the socket:\r\nsocket.connect()\r\nconsole.log('connected to websocket')\r\n\r\n// Now that you are connected, you can join channels with a topic.\r\n// Let's assume you have a channel with a topic named `room` and the\r\n// subtopic is its id - in this case 42:\r\n// let channel = socket.channel(\"nodes:lobby\", {})\r\n\r\n\r\nexport default socket\r\n","\nrequire.register(\"phoenix_html/priv/static/phoenix_html.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"phoenix_html\");\n  (function() {\n    \"use strict\";\n\n(function() {\n  var PolyfillEvent = eventConstructor();\n\n  function eventConstructor() {\n    if (typeof window.CustomEvent === \"function\") return window.CustomEvent;\n    // IE<=9 Support\n    function CustomEvent(event, params) {\n      params = params || {bubbles: false, cancelable: false, detail: undefined};\n      var evt = document.createEvent('CustomEvent');\n      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n      return evt;\n    }\n    CustomEvent.prototype = window.Event.prototype;\n    return CustomEvent;\n  }\n\n  function buildHiddenInput(name, value) {\n    var input = document.createElement(\"input\");\n    input.type = \"hidden\";\n    input.name = name;\n    input.value = value;\n    return input;\n  }\n\n  function handleClick(element, targetModifierKey) {\n    var to = element.getAttribute(\"data-to\"),\n        method = buildHiddenInput(\"_method\", element.getAttribute(\"data-method\")),\n        csrf = buildHiddenInput(\"_csrf_token\", element.getAttribute(\"data-csrf\")),\n        form = document.createElement(\"form\"),\n        target = element.getAttribute(\"target\");\n\n    form.method = (element.getAttribute(\"data-method\") === \"get\") ? \"get\" : \"post\";\n    form.action = to;\n    form.style.display = \"hidden\";\n\n    if (target) form.target = target;\n    else if (targetModifierKey) form.target = \"_blank\";\n\n    form.appendChild(csrf);\n    form.appendChild(method);\n    document.body.appendChild(form);\n    form.submit();\n  }\n\n  window.addEventListener(\"click\", function(e) {\n    var element = e.target;\n    if (e.defaultPrevented) return;\n\n    while (element && element.getAttribute) {\n      var phoenixLinkEvent = new PolyfillEvent('phoenix.link.click', {\n        \"bubbles\": true, \"cancelable\": true\n      });\n\n      if (!element.dispatchEvent(phoenixLinkEvent)) {\n        e.preventDefault();\n        e.stopImmediatePropagation();\n        return false;\n      }\n\n      if (element.getAttribute(\"data-method\")) {\n        handleClick(element, e.metaKey || e.shiftKey);\n        e.preventDefault();\n        return false;\n      } else {\n        element = element.parentNode;\n      }\n    }\n  }, false);\n\n  window.addEventListener('phoenix.link.click', function (e) {\n    var message = e.target.getAttribute(\"data-confirm\");\n    if(message && !window.confirm(message)) {\n      e.preventDefault();\n    }\n  }, false);\n})();\n  })();\n});","\nrequire.register(\"phoenix/priv/static/phoenix.cjs.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"phoenix\");\n  (function() {\n    var __defProp = Object.defineProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// js/phoenix/index.js\n__export(exports, {\n  Channel: () => Channel,\n  LongPoll: () => LongPoll,\n  Presence: () => Presence,\n  Serializer: () => serializer_default,\n  Socket: () => Socket\n});\n\n// js/phoenix/utils.js\nvar closure = (value) => {\n  if (typeof value === \"function\") {\n    return value;\n  } else {\n    let closure2 = function() {\n      return value;\n    };\n    return closure2;\n  }\n};\n\n// js/phoenix/constants.js\nvar globalSelf = typeof self !== \"undefined\" ? self : null;\nvar phxWindow = typeof window !== \"undefined\" ? window : null;\nvar global = globalSelf || phxWindow || void 0;\nvar DEFAULT_VSN = \"2.0.0\";\nvar SOCKET_STATES = { connecting: 0, open: 1, closing: 2, closed: 3 };\nvar DEFAULT_TIMEOUT = 1e4;\nvar WS_CLOSE_NORMAL = 1e3;\nvar CHANNEL_STATES = {\n  closed: \"closed\",\n  errored: \"errored\",\n  joined: \"joined\",\n  joining: \"joining\",\n  leaving: \"leaving\"\n};\nvar CHANNEL_EVENTS = {\n  close: \"phx_close\",\n  error: \"phx_error\",\n  join: \"phx_join\",\n  reply: \"phx_reply\",\n  leave: \"phx_leave\"\n};\nvar TRANSPORTS = {\n  longpoll: \"longpoll\",\n  websocket: \"websocket\"\n};\nvar XHR_STATES = {\n  complete: 4\n};\n\n// js/phoenix/push.js\nvar Push = class {\n  constructor(channel, event, payload, timeout) {\n    this.channel = channel;\n    this.event = event;\n    this.payload = payload || function() {\n      return {};\n    };\n    this.receivedResp = null;\n    this.timeout = timeout;\n    this.timeoutTimer = null;\n    this.recHooks = [];\n    this.sent = false;\n  }\n  resend(timeout) {\n    this.timeout = timeout;\n    this.reset();\n    this.send();\n  }\n  send() {\n    if (this.hasReceived(\"timeout\")) {\n      return;\n    }\n    this.startTimeout();\n    this.sent = true;\n    this.channel.socket.push({\n      topic: this.channel.topic,\n      event: this.event,\n      payload: this.payload(),\n      ref: this.ref,\n      join_ref: this.channel.joinRef()\n    });\n  }\n  receive(status, callback) {\n    if (this.hasReceived(status)) {\n      callback(this.receivedResp.response);\n    }\n    this.recHooks.push({ status, callback });\n    return this;\n  }\n  reset() {\n    this.cancelRefEvent();\n    this.ref = null;\n    this.refEvent = null;\n    this.receivedResp = null;\n    this.sent = false;\n  }\n  matchReceive({ status, response, _ref }) {\n    this.recHooks.filter((h) => h.status === status).forEach((h) => h.callback(response));\n  }\n  cancelRefEvent() {\n    if (!this.refEvent) {\n      return;\n    }\n    this.channel.off(this.refEvent);\n  }\n  cancelTimeout() {\n    clearTimeout(this.timeoutTimer);\n    this.timeoutTimer = null;\n  }\n  startTimeout() {\n    if (this.timeoutTimer) {\n      this.cancelTimeout();\n    }\n    this.ref = this.channel.socket.makeRef();\n    this.refEvent = this.channel.replyEventName(this.ref);\n    this.channel.on(this.refEvent, (payload) => {\n      this.cancelRefEvent();\n      this.cancelTimeout();\n      this.receivedResp = payload;\n      this.matchReceive(payload);\n    });\n    this.timeoutTimer = setTimeout(() => {\n      this.trigger(\"timeout\", {});\n    }, this.timeout);\n  }\n  hasReceived(status) {\n    return this.receivedResp && this.receivedResp.status === status;\n  }\n  trigger(status, response) {\n    this.channel.trigger(this.refEvent, { status, response });\n  }\n};\n\n// js/phoenix/timer.js\nvar Timer = class {\n  constructor(callback, timerCalc) {\n    this.callback = callback;\n    this.timerCalc = timerCalc;\n    this.timer = null;\n    this.tries = 0;\n  }\n  reset() {\n    this.tries = 0;\n    clearTimeout(this.timer);\n  }\n  scheduleTimeout() {\n    clearTimeout(this.timer);\n    this.timer = setTimeout(() => {\n      this.tries = this.tries + 1;\n      this.callback();\n    }, this.timerCalc(this.tries + 1));\n  }\n};\n\n// js/phoenix/channel.js\nvar Channel = class {\n  constructor(topic, params, socket) {\n    this.state = CHANNEL_STATES.closed;\n    this.topic = topic;\n    this.params = closure(params || {});\n    this.socket = socket;\n    this.bindings = [];\n    this.bindingRef = 0;\n    this.timeout = this.socket.timeout;\n    this.joinedOnce = false;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.pushBuffer = [];\n    this.stateChangeRefs = [];\n    this.rejoinTimer = new Timer(() => {\n      if (this.socket.isConnected()) {\n        this.rejoin();\n      }\n    }, this.socket.rejoinAfterMs);\n    this.stateChangeRefs.push(this.socket.onError(() => this.rejoinTimer.reset()));\n    this.stateChangeRefs.push(this.socket.onOpen(() => {\n      this.rejoinTimer.reset();\n      if (this.isErrored()) {\n        this.rejoin();\n      }\n    }));\n    this.joinPush.receive(\"ok\", () => {\n      this.state = CHANNEL_STATES.joined;\n      this.rejoinTimer.reset();\n      this.pushBuffer.forEach((pushEvent) => pushEvent.send());\n      this.pushBuffer = [];\n    });\n    this.joinPush.receive(\"error\", () => {\n      this.state = CHANNEL_STATES.errored;\n      if (this.socket.isConnected()) {\n        this.rejoinTimer.scheduleTimeout();\n      }\n    });\n    this.onClose(() => {\n      this.rejoinTimer.reset();\n      if (this.socket.hasLogger())\n        this.socket.log(\"channel\", `close ${this.topic} ${this.joinRef()}`);\n      this.state = CHANNEL_STATES.closed;\n      this.socket.remove(this);\n    });\n    this.onError((reason) => {\n      if (this.socket.hasLogger())\n        this.socket.log(\"channel\", `error ${this.topic}`, reason);\n      if (this.isJoining()) {\n        this.joinPush.reset();\n      }\n      this.state = CHANNEL_STATES.errored;\n      if (this.socket.isConnected()) {\n        this.rejoinTimer.scheduleTimeout();\n      }\n    });\n    this.joinPush.receive(\"timeout\", () => {\n      if (this.socket.hasLogger())\n        this.socket.log(\"channel\", `timeout ${this.topic} (${this.joinRef()})`, this.joinPush.timeout);\n      let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout);\n      leavePush.send();\n      this.state = CHANNEL_STATES.errored;\n      this.joinPush.reset();\n      if (this.socket.isConnected()) {\n        this.rejoinTimer.scheduleTimeout();\n      }\n    });\n    this.on(CHANNEL_EVENTS.reply, (payload, ref) => {\n      this.trigger(this.replyEventName(ref), payload);\n    });\n  }\n  join(timeout = this.timeout) {\n    if (this.joinedOnce) {\n      throw new Error(\"tried to join multiple times. 'join' can only be called a single time per channel instance\");\n    } else {\n      this.timeout = timeout;\n      this.joinedOnce = true;\n      this.rejoin();\n      return this.joinPush;\n    }\n  }\n  onClose(callback) {\n    this.on(CHANNEL_EVENTS.close, callback);\n  }\n  onError(callback) {\n    return this.on(CHANNEL_EVENTS.error, (reason) => callback(reason));\n  }\n  on(event, callback) {\n    let ref = this.bindingRef++;\n    this.bindings.push({ event, ref, callback });\n    return ref;\n  }\n  off(event, ref) {\n    this.bindings = this.bindings.filter((bind) => {\n      return !(bind.event === event && (typeof ref === \"undefined\" || ref === bind.ref));\n    });\n  }\n  canPush() {\n    return this.socket.isConnected() && this.isJoined();\n  }\n  push(event, payload, timeout = this.timeout) {\n    payload = payload || {};\n    if (!this.joinedOnce) {\n      throw new Error(`tried to push '${event}' to '${this.topic}' before joining. Use channel.join() before pushing events`);\n    }\n    let pushEvent = new Push(this, event, function() {\n      return payload;\n    }, timeout);\n    if (this.canPush()) {\n      pushEvent.send();\n    } else {\n      pushEvent.startTimeout();\n      this.pushBuffer.push(pushEvent);\n    }\n    return pushEvent;\n  }\n  leave(timeout = this.timeout) {\n    this.rejoinTimer.reset();\n    this.joinPush.cancelTimeout();\n    this.state = CHANNEL_STATES.leaving;\n    let onClose = () => {\n      if (this.socket.hasLogger())\n        this.socket.log(\"channel\", `leave ${this.topic}`);\n      this.trigger(CHANNEL_EVENTS.close, \"leave\");\n    };\n    let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout);\n    leavePush.receive(\"ok\", () => onClose()).receive(\"timeout\", () => onClose());\n    leavePush.send();\n    if (!this.canPush()) {\n      leavePush.trigger(\"ok\", {});\n    }\n    return leavePush;\n  }\n  onMessage(_event, payload, _ref) {\n    return payload;\n  }\n  isMember(topic, event, payload, joinRef) {\n    if (this.topic !== topic) {\n      return false;\n    }\n    if (joinRef && joinRef !== this.joinRef()) {\n      if (this.socket.hasLogger())\n        this.socket.log(\"channel\", \"dropping outdated message\", { topic, event, payload, joinRef });\n      return false;\n    } else {\n      return true;\n    }\n  }\n  joinRef() {\n    return this.joinPush.ref;\n  }\n  rejoin(timeout = this.timeout) {\n    if (this.isLeaving()) {\n      return;\n    }\n    this.socket.leaveOpenTopic(this.topic);\n    this.state = CHANNEL_STATES.joining;\n    this.joinPush.resend(timeout);\n  }\n  trigger(event, payload, ref, joinRef) {\n    let handledPayload = this.onMessage(event, payload, ref, joinRef);\n    if (payload && !handledPayload) {\n      throw new Error(\"channel onMessage callbacks must return the payload, modified or unmodified\");\n    }\n    let eventBindings = this.bindings.filter((bind) => bind.event === event);\n    for (let i = 0; i < eventBindings.length; i++) {\n      let bind = eventBindings[i];\n      bind.callback(handledPayload, ref, joinRef || this.joinRef());\n    }\n  }\n  replyEventName(ref) {\n    return `chan_reply_${ref}`;\n  }\n  isClosed() {\n    return this.state === CHANNEL_STATES.closed;\n  }\n  isErrored() {\n    return this.state === CHANNEL_STATES.errored;\n  }\n  isJoined() {\n    return this.state === CHANNEL_STATES.joined;\n  }\n  isJoining() {\n    return this.state === CHANNEL_STATES.joining;\n  }\n  isLeaving() {\n    return this.state === CHANNEL_STATES.leaving;\n  }\n};\n\n// js/phoenix/ajax.js\nvar Ajax = class {\n  static request(method, endPoint, accept, body, timeout, ontimeout, callback) {\n    if (global.XDomainRequest) {\n      let req = new global.XDomainRequest();\n      this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);\n    } else {\n      let req = new global.XMLHttpRequest();\n      this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback);\n    }\n  }\n  static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {\n    req.timeout = timeout;\n    req.open(method, endPoint);\n    req.onload = () => {\n      let response = this.parseJSON(req.responseText);\n      callback && callback(response);\n    };\n    if (ontimeout) {\n      req.ontimeout = ontimeout;\n    }\n    req.onprogress = () => {\n    };\n    req.send(body);\n  }\n  static xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback) {\n    req.open(method, endPoint, true);\n    req.timeout = timeout;\n    req.setRequestHeader(\"Content-Type\", accept);\n    req.onerror = () => {\n      callback && callback(null);\n    };\n    req.onreadystatechange = () => {\n      if (req.readyState === XHR_STATES.complete && callback) {\n        let response = this.parseJSON(req.responseText);\n        callback(response);\n      }\n    };\n    if (ontimeout) {\n      req.ontimeout = ontimeout;\n    }\n    req.send(body);\n  }\n  static parseJSON(resp) {\n    if (!resp || resp === \"\") {\n      return null;\n    }\n    try {\n      return JSON.parse(resp);\n    } catch (e) {\n      console && console.log(\"failed to parse JSON response\", resp);\n      return null;\n    }\n  }\n  static serialize(obj, parentKey) {\n    let queryStr = [];\n    for (var key in obj) {\n      if (!Object.prototype.hasOwnProperty.call(obj, key)) {\n        continue;\n      }\n      let paramKey = parentKey ? `${parentKey}[${key}]` : key;\n      let paramVal = obj[key];\n      if (typeof paramVal === \"object\") {\n        queryStr.push(this.serialize(paramVal, paramKey));\n      } else {\n        queryStr.push(encodeURIComponent(paramKey) + \"=\" + encodeURIComponent(paramVal));\n      }\n    }\n    return queryStr.join(\"&\");\n  }\n  static appendParams(url, params) {\n    if (Object.keys(params).length === 0) {\n      return url;\n    }\n    let prefix = url.match(/\\?/) ? \"&\" : \"?\";\n    return `${url}${prefix}${this.serialize(params)}`;\n  }\n};\n\n// js/phoenix/longpoll.js\nvar LongPoll = class {\n  constructor(endPoint) {\n    this.endPoint = null;\n    this.token = null;\n    this.skipHeartbeat = true;\n    this.onopen = function() {\n    };\n    this.onerror = function() {\n    };\n    this.onmessage = function() {\n    };\n    this.onclose = function() {\n    };\n    this.pollEndpoint = this.normalizeEndpoint(endPoint);\n    this.readyState = SOCKET_STATES.connecting;\n    this.poll();\n  }\n  normalizeEndpoint(endPoint) {\n    return endPoint.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\").replace(new RegExp(\"(.*)/\" + TRANSPORTS.websocket), \"$1/\" + TRANSPORTS.longpoll);\n  }\n  endpointURL() {\n    return Ajax.appendParams(this.pollEndpoint, { token: this.token });\n  }\n  closeAndRetry() {\n    this.close();\n    this.readyState = SOCKET_STATES.connecting;\n  }\n  ontimeout() {\n    this.onerror(\"timeout\");\n    this.closeAndRetry();\n  }\n  poll() {\n    if (!(this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting)) {\n      return;\n    }\n    Ajax.request(\"GET\", this.endpointURL(), \"application/json\", null, this.timeout, this.ontimeout.bind(this), (resp) => {\n      if (resp) {\n        var { status, token, messages } = resp;\n        this.token = token;\n      } else {\n        status = 0;\n      }\n      switch (status) {\n        case 200:\n          messages.forEach((msg) => {\n            setTimeout(() => {\n              this.onmessage({ data: msg });\n            }, 0);\n          });\n          this.poll();\n          break;\n        case 204:\n          this.poll();\n          break;\n        case 410:\n          this.readyState = SOCKET_STATES.open;\n          this.onopen();\n          this.poll();\n          break;\n        case 403:\n          this.onerror();\n          this.close();\n          break;\n        case 0:\n        case 500:\n          this.onerror();\n          this.closeAndRetry();\n          break;\n        default:\n          throw new Error(`unhandled poll status ${status}`);\n      }\n    });\n  }\n  send(body) {\n    Ajax.request(\"POST\", this.endpointURL(), \"application/json\", body, this.timeout, this.onerror.bind(this, \"timeout\"), (resp) => {\n      if (!resp || resp.status !== 200) {\n        this.onerror(resp && resp.status);\n        this.closeAndRetry();\n      }\n    });\n  }\n  close(_code, _reason) {\n    this.readyState = SOCKET_STATES.closed;\n    this.onclose();\n  }\n};\n\n// js/phoenix/presence.js\nvar Presence = class {\n  constructor(channel, opts = {}) {\n    let events = opts.events || { state: \"presence_state\", diff: \"presence_diff\" };\n    this.state = {};\n    this.pendingDiffs = [];\n    this.channel = channel;\n    this.joinRef = null;\n    this.caller = {\n      onJoin: function() {\n      },\n      onLeave: function() {\n      },\n      onSync: function() {\n      }\n    };\n    this.channel.on(events.state, (newState) => {\n      let { onJoin, onLeave, onSync } = this.caller;\n      this.joinRef = this.channel.joinRef();\n      this.state = Presence.syncState(this.state, newState, onJoin, onLeave);\n      this.pendingDiffs.forEach((diff) => {\n        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);\n      });\n      this.pendingDiffs = [];\n      onSync();\n    });\n    this.channel.on(events.diff, (diff) => {\n      let { onJoin, onLeave, onSync } = this.caller;\n      if (this.inPendingSyncState()) {\n        this.pendingDiffs.push(diff);\n      } else {\n        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);\n        onSync();\n      }\n    });\n  }\n  onJoin(callback) {\n    this.caller.onJoin = callback;\n  }\n  onLeave(callback) {\n    this.caller.onLeave = callback;\n  }\n  onSync(callback) {\n    this.caller.onSync = callback;\n  }\n  list(by) {\n    return Presence.list(this.state, by);\n  }\n  inPendingSyncState() {\n    return !this.joinRef || this.joinRef !== this.channel.joinRef();\n  }\n  static syncState(currentState, newState, onJoin, onLeave) {\n    let state = this.clone(currentState);\n    let joins = {};\n    let leaves = {};\n    this.map(state, (key, presence) => {\n      if (!newState[key]) {\n        leaves[key] = presence;\n      }\n    });\n    this.map(newState, (key, newPresence) => {\n      let currentPresence = state[key];\n      if (currentPresence) {\n        let newRefs = newPresence.metas.map((m) => m.phx_ref);\n        let curRefs = currentPresence.metas.map((m) => m.phx_ref);\n        let joinedMetas = newPresence.metas.filter((m) => curRefs.indexOf(m.phx_ref) < 0);\n        let leftMetas = currentPresence.metas.filter((m) => newRefs.indexOf(m.phx_ref) < 0);\n        if (joinedMetas.length > 0) {\n          joins[key] = newPresence;\n          joins[key].metas = joinedMetas;\n        }\n        if (leftMetas.length > 0) {\n          leaves[key] = this.clone(currentPresence);\n          leaves[key].metas = leftMetas;\n        }\n      } else {\n        joins[key] = newPresence;\n      }\n    });\n    return this.syncDiff(state, { joins, leaves }, onJoin, onLeave);\n  }\n  static syncDiff(state, diff, onJoin, onLeave) {\n    let { joins, leaves } = this.clone(diff);\n    if (!onJoin) {\n      onJoin = function() {\n      };\n    }\n    if (!onLeave) {\n      onLeave = function() {\n      };\n    }\n    this.map(joins, (key, newPresence) => {\n      let currentPresence = state[key];\n      state[key] = this.clone(newPresence);\n      if (currentPresence) {\n        let joinedRefs = state[key].metas.map((m) => m.phx_ref);\n        let curMetas = currentPresence.metas.filter((m) => joinedRefs.indexOf(m.phx_ref) < 0);\n        state[key].metas.unshift(...curMetas);\n      }\n      onJoin(key, currentPresence, newPresence);\n    });\n    this.map(leaves, (key, leftPresence) => {\n      let currentPresence = state[key];\n      if (!currentPresence) {\n        return;\n      }\n      let refsToRemove = leftPresence.metas.map((m) => m.phx_ref);\n      currentPresence.metas = currentPresence.metas.filter((p) => {\n        return refsToRemove.indexOf(p.phx_ref) < 0;\n      });\n      onLeave(key, currentPresence, leftPresence);\n      if (currentPresence.metas.length === 0) {\n        delete state[key];\n      }\n    });\n    return state;\n  }\n  static list(presences, chooser) {\n    if (!chooser) {\n      chooser = function(key, pres) {\n        return pres;\n      };\n    }\n    return this.map(presences, (key, presence) => {\n      return chooser(key, presence);\n    });\n  }\n  static map(obj, func) {\n    return Object.getOwnPropertyNames(obj).map((key) => func(key, obj[key]));\n  }\n  static clone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  }\n};\n\n// js/phoenix/serializer.js\nvar serializer_default = {\n  HEADER_LENGTH: 1,\n  META_LENGTH: 4,\n  KINDS: { push: 0, reply: 1, broadcast: 2 },\n  encode(msg, callback) {\n    if (msg.payload.constructor === ArrayBuffer) {\n      return callback(this.binaryEncode(msg));\n    } else {\n      let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];\n      return callback(JSON.stringify(payload));\n    }\n  },\n  decode(rawPayload, callback) {\n    if (rawPayload.constructor === ArrayBuffer) {\n      return callback(this.binaryDecode(rawPayload));\n    } else {\n      let [join_ref, ref, topic, event, payload] = JSON.parse(rawPayload);\n      return callback({ join_ref, ref, topic, event, payload });\n    }\n  },\n  binaryEncode(message) {\n    let { join_ref, ref, event, topic, payload } = message;\n    let metaLength = this.META_LENGTH + join_ref.length + ref.length + topic.length + event.length;\n    let header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);\n    let view = new DataView(header);\n    let offset = 0;\n    view.setUint8(offset++, this.KINDS.push);\n    view.setUint8(offset++, join_ref.length);\n    view.setUint8(offset++, ref.length);\n    view.setUint8(offset++, topic.length);\n    view.setUint8(offset++, event.length);\n    Array.from(join_ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));\n    Array.from(ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));\n    Array.from(topic, (char) => view.setUint8(offset++, char.charCodeAt(0)));\n    Array.from(event, (char) => view.setUint8(offset++, char.charCodeAt(0)));\n    var combined = new Uint8Array(header.byteLength + payload.byteLength);\n    combined.set(new Uint8Array(header), 0);\n    combined.set(new Uint8Array(payload), header.byteLength);\n    return combined.buffer;\n  },\n  binaryDecode(buffer) {\n    let view = new DataView(buffer);\n    let kind = view.getUint8(0);\n    let decoder = new TextDecoder();\n    switch (kind) {\n      case this.KINDS.push:\n        return this.decodePush(buffer, view, decoder);\n      case this.KINDS.reply:\n        return this.decodeReply(buffer, view, decoder);\n      case this.KINDS.broadcast:\n        return this.decodeBroadcast(buffer, view, decoder);\n    }\n  },\n  decodePush(buffer, view, decoder) {\n    let joinRefSize = view.getUint8(1);\n    let topicSize = view.getUint8(2);\n    let eventSize = view.getUint8(3);\n    let offset = this.HEADER_LENGTH + this.META_LENGTH - 1;\n    let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));\n    offset = offset + joinRefSize;\n    let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n    offset = offset + topicSize;\n    let event = decoder.decode(buffer.slice(offset, offset + eventSize));\n    offset = offset + eventSize;\n    let data = buffer.slice(offset, buffer.byteLength);\n    return { join_ref: joinRef, ref: null, topic, event, payload: data };\n  },\n  decodeReply(buffer, view, decoder) {\n    let joinRefSize = view.getUint8(1);\n    let refSize = view.getUint8(2);\n    let topicSize = view.getUint8(3);\n    let eventSize = view.getUint8(4);\n    let offset = this.HEADER_LENGTH + this.META_LENGTH;\n    let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));\n    offset = offset + joinRefSize;\n    let ref = decoder.decode(buffer.slice(offset, offset + refSize));\n    offset = offset + refSize;\n    let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n    offset = offset + topicSize;\n    let event = decoder.decode(buffer.slice(offset, offset + eventSize));\n    offset = offset + eventSize;\n    let data = buffer.slice(offset, buffer.byteLength);\n    let payload = { status: event, response: data };\n    return { join_ref: joinRef, ref, topic, event: CHANNEL_EVENTS.reply, payload };\n  },\n  decodeBroadcast(buffer, view, decoder) {\n    let topicSize = view.getUint8(1);\n    let eventSize = view.getUint8(2);\n    let offset = this.HEADER_LENGTH + 2;\n    let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n    offset = offset + topicSize;\n    let event = decoder.decode(buffer.slice(offset, offset + eventSize));\n    offset = offset + eventSize;\n    let data = buffer.slice(offset, buffer.byteLength);\n    return { join_ref: null, ref: null, topic, event, payload: data };\n  }\n};\n\n// js/phoenix/socket.js\nvar Socket = class {\n  constructor(endPoint, opts = {}) {\n    this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] };\n    this.channels = [];\n    this.sendBuffer = [];\n    this.ref = 0;\n    this.timeout = opts.timeout || DEFAULT_TIMEOUT;\n    this.transport = opts.transport || global.WebSocket || LongPoll;\n    this.establishedConnections = 0;\n    this.defaultEncoder = serializer_default.encode.bind(serializer_default);\n    this.defaultDecoder = serializer_default.decode.bind(serializer_default);\n    this.closeWasClean = false;\n    this.binaryType = opts.binaryType || \"arraybuffer\";\n    this.connectClock = 1;\n    if (this.transport !== LongPoll) {\n      this.encode = opts.encode || this.defaultEncoder;\n      this.decode = opts.decode || this.defaultDecoder;\n    } else {\n      this.encode = this.defaultEncoder;\n      this.decode = this.defaultDecoder;\n    }\n    let awaitingConnectionOnPageShow = null;\n    if (phxWindow && phxWindow.addEventListener) {\n      phxWindow.addEventListener(\"pagehide\", (_e) => {\n        if (this.conn) {\n          this.disconnect();\n          awaitingConnectionOnPageShow = this.connectClock;\n        }\n      });\n      phxWindow.addEventListener(\"pageshow\", (_e) => {\n        if (awaitingConnectionOnPageShow === this.connectClock) {\n          awaitingConnectionOnPageShow = null;\n          this.connect();\n        }\n      });\n    }\n    this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 3e4;\n    this.rejoinAfterMs = (tries) => {\n      if (opts.rejoinAfterMs) {\n        return opts.rejoinAfterMs(tries);\n      } else {\n        return [1e3, 2e3, 5e3][tries - 1] || 1e4;\n      }\n    };\n    this.reconnectAfterMs = (tries) => {\n      if (opts.reconnectAfterMs) {\n        return opts.reconnectAfterMs(tries);\n      } else {\n        return [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][tries - 1] || 5e3;\n      }\n    };\n    this.logger = opts.logger || null;\n    this.longpollerTimeout = opts.longpollerTimeout || 2e4;\n    this.params = closure(opts.params || {});\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n    this.vsn = opts.vsn || DEFAULT_VSN;\n    this.heartbeatTimer = null;\n    this.pendingHeartbeatRef = null;\n    this.reconnectTimer = new Timer(() => {\n      this.teardown(() => this.connect());\n    }, this.reconnectAfterMs);\n  }\n  replaceTransport(newTransport) {\n    this.disconnect();\n    this.transport = newTransport;\n  }\n  protocol() {\n    return location.protocol.match(/^https/) ? \"wss\" : \"ws\";\n  }\n  endPointURL() {\n    let uri = Ajax.appendParams(Ajax.appendParams(this.endPoint, this.params()), { vsn: this.vsn });\n    if (uri.charAt(0) !== \"/\") {\n      return uri;\n    }\n    if (uri.charAt(1) === \"/\") {\n      return `${this.protocol()}:${uri}`;\n    }\n    return `${this.protocol()}://${location.host}${uri}`;\n  }\n  disconnect(callback, code, reason) {\n    this.connectClock++;\n    this.closeWasClean = true;\n    this.reconnectTimer.reset();\n    this.teardown(callback, code, reason);\n  }\n  connect(params) {\n    this.connectClock++;\n    if (params) {\n      console && console.log(\"passing params to connect is deprecated. Instead pass :params to the Socket constructor\");\n      this.params = closure(params);\n    }\n    if (this.conn) {\n      return;\n    }\n    this.closeWasClean = false;\n    this.conn = new this.transport(this.endPointURL());\n    this.conn.binaryType = this.binaryType;\n    this.conn.timeout = this.longpollerTimeout;\n    this.conn.onopen = () => this.onConnOpen();\n    this.conn.onerror = (error) => this.onConnError(error);\n    this.conn.onmessage = (event) => this.onConnMessage(event);\n    this.conn.onclose = (event) => this.onConnClose(event);\n  }\n  log(kind, msg, data) {\n    this.logger(kind, msg, data);\n  }\n  hasLogger() {\n    return this.logger !== null;\n  }\n  onOpen(callback) {\n    let ref = this.makeRef();\n    this.stateChangeCallbacks.open.push([ref, callback]);\n    return ref;\n  }\n  onClose(callback) {\n    let ref = this.makeRef();\n    this.stateChangeCallbacks.close.push([ref, callback]);\n    return ref;\n  }\n  onError(callback) {\n    let ref = this.makeRef();\n    this.stateChangeCallbacks.error.push([ref, callback]);\n    return ref;\n  }\n  onMessage(callback) {\n    let ref = this.makeRef();\n    this.stateChangeCallbacks.message.push([ref, callback]);\n    return ref;\n  }\n  onConnOpen() {\n    if (this.hasLogger())\n      this.log(\"transport\", `connected to ${this.endPointURL()}`);\n    this.closeWasClean = false;\n    this.establishedConnections++;\n    this.flushSendBuffer();\n    this.reconnectTimer.reset();\n    this.resetHeartbeat();\n    this.stateChangeCallbacks.open.forEach(([, callback]) => callback());\n  }\n  heartbeatTimeout() {\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null;\n      if (this.hasLogger()) {\n        this.log(\"transport\", \"heartbeat timeout. Attempting to re-establish connection\");\n      }\n      this.abnormalClose(\"heartbeat timeout\");\n    }\n  }\n  resetHeartbeat() {\n    if (this.conn && this.conn.skipHeartbeat) {\n      return;\n    }\n    this.pendingHeartbeatRef = null;\n    clearTimeout(this.heartbeatTimer);\n    setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\n  }\n  teardown(callback, code, reason) {\n    if (!this.conn) {\n      return callback && callback();\n    }\n    this.waitForBufferDone(() => {\n      if (this.conn) {\n        if (code) {\n          this.conn.close(code, reason || \"\");\n        } else {\n          this.conn.close();\n        }\n      }\n      this.waitForSocketClosed(() => {\n        if (this.conn) {\n          this.conn.onclose = function() {\n          };\n          this.conn = null;\n        }\n        callback && callback();\n      });\n    });\n  }\n  waitForBufferDone(callback, tries = 1) {\n    if (tries === 5 || !this.conn || !this.conn.bufferedAmount) {\n      callback();\n      return;\n    }\n    setTimeout(() => {\n      this.waitForBufferDone(callback, tries + 1);\n    }, 150 * tries);\n  }\n  waitForSocketClosed(callback, tries = 1) {\n    if (tries === 5 || !this.conn || this.conn.readyState === SOCKET_STATES.closed) {\n      callback();\n      return;\n    }\n    setTimeout(() => {\n      this.waitForSocketClosed(callback, tries + 1);\n    }, 150 * tries);\n  }\n  onConnClose(event) {\n    let closeCode = event && event.code;\n    if (this.hasLogger())\n      this.log(\"transport\", \"close\", event);\n    this.triggerChanError();\n    clearTimeout(this.heartbeatTimer);\n    if (!this.closeWasClean && closeCode !== 1e3) {\n      this.reconnectTimer.scheduleTimeout();\n    }\n    this.stateChangeCallbacks.close.forEach(([, callback]) => callback(event));\n  }\n  onConnError(error) {\n    if (this.hasLogger())\n      this.log(\"transport\", error);\n    let transportBefore = this.transport;\n    let establishedBefore = this.establishedConnections;\n    this.stateChangeCallbacks.error.forEach(([, callback]) => {\n      callback(error, transportBefore, establishedBefore);\n    });\n    if (transportBefore === this.transport || establishedBefore > 0) {\n      this.triggerChanError();\n    }\n  }\n  triggerChanError() {\n    this.channels.forEach((channel) => {\n      if (!(channel.isErrored() || channel.isLeaving() || channel.isClosed())) {\n        channel.trigger(CHANNEL_EVENTS.error);\n      }\n    });\n  }\n  connectionState() {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return \"connecting\";\n      case SOCKET_STATES.open:\n        return \"open\";\n      case SOCKET_STATES.closing:\n        return \"closing\";\n      default:\n        return \"closed\";\n    }\n  }\n  isConnected() {\n    return this.connectionState() === \"open\";\n  }\n  remove(channel) {\n    this.off(channel.stateChangeRefs);\n    this.channels = this.channels.filter((c) => c.joinRef() !== channel.joinRef());\n  }\n  off(refs) {\n    for (let key in this.stateChangeCallbacks) {\n      this.stateChangeCallbacks[key] = this.stateChangeCallbacks[key].filter(([ref]) => {\n        return refs.indexOf(ref) === -1;\n      });\n    }\n  }\n  channel(topic, chanParams = {}) {\n    let chan = new Channel(topic, chanParams, this);\n    this.channels.push(chan);\n    return chan;\n  }\n  push(data) {\n    if (this.hasLogger()) {\n      let { topic, event, payload, ref, join_ref } = data;\n      this.log(\"push\", `${topic} ${event} (${join_ref}, ${ref})`, payload);\n    }\n    if (this.isConnected()) {\n      this.encode(data, (result) => this.conn.send(result));\n    } else {\n      this.sendBuffer.push(() => this.encode(data, (result) => this.conn.send(result)));\n    }\n  }\n  makeRef() {\n    let newRef = this.ref + 1;\n    if (newRef === this.ref) {\n      this.ref = 0;\n    } else {\n      this.ref = newRef;\n    }\n    return this.ref.toString();\n  }\n  sendHeartbeat() {\n    if (this.pendingHeartbeatRef && !this.isConnected()) {\n      return;\n    }\n    this.pendingHeartbeatRef = this.makeRef();\n    this.push({ topic: \"phoenix\", event: \"heartbeat\", payload: {}, ref: this.pendingHeartbeatRef });\n    this.heartbeatTimer = setTimeout(() => this.heartbeatTimeout(), this.heartbeatIntervalMs);\n  }\n  abnormalClose(reason) {\n    this.closeWasClean = false;\n    if (this.isConnected()) {\n      this.conn.close(WS_CLOSE_NORMAL, reason);\n    }\n  }\n  flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach((callback) => callback());\n      this.sendBuffer = [];\n    }\n  }\n  onConnMessage(rawMessage) {\n    this.decode(rawMessage.data, (msg) => {\n      let { topic, event, payload, ref, join_ref } = msg;\n      if (ref && ref === this.pendingHeartbeatRef) {\n        clearTimeout(this.heartbeatTimer);\n        this.pendingHeartbeatRef = null;\n        setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\n      }\n      if (this.hasLogger())\n        this.log(\"receive\", `${payload.status || \"\"} ${topic} ${event} ${ref && \"(\" + ref + \")\" || \"\"}`, payload);\n      for (let i = 0; i < this.channels.length; i++) {\n        const channel = this.channels[i];\n        if (!channel.isMember(topic, event, payload, join_ref)) {\n          continue;\n        }\n        channel.trigger(event, payload, ref, join_ref);\n      }\n      for (let i = 0; i < this.stateChangeCallbacks.message.length; i++) {\n        let [, callback] = this.stateChangeCallbacks.message[i];\n        callback(msg);\n      }\n    });\n  }\n  leaveOpenTopic(topic) {\n    let dupChannel = this.channels.find((c) => c.topic === topic && (c.isJoined() || c.isJoining()));\n    if (dupChannel) {\n      if (this.hasLogger())\n        this.log(\"transport\", `leaving duplicate topic \"${topic}\"`);\n      dupChannel.leave();\n    }\n  }\n};\n//# sourceMappingURL=phoenix.cjs.js.map\n  })();\n});"]}